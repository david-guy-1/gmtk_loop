<html>

<head>

<script type="text/javascript">
// workaround to get tsc output to work
//// canvasDrawing, process_draws, lines  - ts to js, remove all "export"
function define(x,y,z){
z(window,window,window,window,window,window,window,window,window,window,window,window);
}
</script>
<script type="text/javascript" src="canvasDrawing.js"></script><script type="text/javascript" src="lines.js"></script><script type="text/javascript" src="lodash.js"></script><script type="text/javascript" src="process_draws.js"></script>
</head>

<body onload="load()">
    <canvas id='bigc' width="800px" height="600px" style="border:1px solid black;zIndex:2">
        Canvas not supported
      </canvas>
      <br />
      <table><tr><td>
      <textarea id="text"></textarea><br />
      <button onclick="lst.pop();draw();">Pop (W)</button>
      <button onclick="if(prompt('confirm')){lst = []};draw();">Clear</button>
      <button onclick="document.getElementById('text').value = JSON.stringify(lst)">Save</button>
      <button onclick="lst = JSON.parse(document.getElementById('text').value);draw();">Load</button><br />
		Mode : <select name="choices" id="choices" onChange="draw()">
			<option value="circles">circles</option>
			<option value="lines">lines</option>
			<option value="polygon">polygon</option>
			<option value="bezier">bezier</option>
			<option value="bezier shape">bezier shape</option>
			<option value="smooth bezier">smooth bezier</option>
			<option value="smooth bezier shape">smooth bezier shape</option>
			</select> Circles <input type="checkbox" id="circle_check" onChange="draw()" checked=true/>Numbers <input type="checkbox" id="number_check" onChange="draw()" checked=true/>
    </td><td>
        .......
    </td><td>
        x0 : <input type="text" id="rescale_x0"> x1 : <input type="text" id="rescale_x1"> <br />
        y0 : <input type="text" id="rescale_y0"> y1 : <input type="text" id="rescale_y1"> <br />
        <button onclick="rescale()">Rescale</button>
        <button onclick="rescale_max()">Rescale Max</button>
        <button onclick="rescale_01()">Rescale 01</button>
    </td>
        </tr></table>
    <br />
    Q to move point, E to cancel move <br />
    <b>Rescale : </b> Given the numbers x0, x1, y0, y1 - consider the affine linear function that sends x0 to 0 and x1 to 1 (similarly for y0), maps the given points under this function <br />
    rescale max : rescales with x0 = 0, x1 = max value of x, y0 = max value of y, y1 = min value of y <br />
    rescale 01 : rescales with x0 = 0, x1 = 400, y0 = 600, y1 = 0
</body>

<script type="text/javascript" src="lodash.js"></script>
<script>
let lst = [];
let c; 
let moved_point = undefined; 
let mouse_loc = [0,0];
function load()  { 
    document.addEventListener("keyup", function(e){
		if(e.key.toLowerCase() == "q"){
            moved_point = getClosestPoint(); 
            draw();
        }
        if(e.key.toLowerCase() == "e"){
            moved_point = undefined;
            draw();
        }
		
        if(e.key.toLowerCase() == "w"){
            lst.pop(); 
            draw();
        } 
    })
    document.getElementById("bigc").addEventListener("click", function(e){ 
        if(moved_point == undefined){
            lst.push([e.offsetX-400, e.offsetY]);
        } else {
            lst[moved_point] = [e.offsetX-400, e.offsetY]
            moved_point = undefined;
        }
        draw();
    })
    document.getElementById("bigc").addEventListener("mousemove", function(e){ 
        mouse_loc = [e.offsetX-400, e.offsetY];
    })
    c= document.getElementById("bigc").getContext("2d");
    draw();
}

function getClosestPoint(){
    if(lst.length == 0){
        return undefined;
    }
    let closest = -1; 
    let closest_dist = Number.POSITIVE_INFINITY;
    for(let [i, p] of lst.entries()){
        let distance = dist(p, mouse_loc) 
        if(distance < closest_dist){
            closest = i;
            closest_dist = distance;
        }
    }
    return closest;
}

function draw(){
    c.clearRect(0,0,1000,1000);
    drawLine(c, 400, 0, 400, 1000, "green", 1); 
    let mode = document.getElementById("choices").selectedOptions[0].innerHTML;
	let points = lst.map(x => [x[0] + 400, x[1]]); // points on screen
	let commands = []; 
	if(document.getElementById("circle_check").checked){
		for(let [i,p] of points.entries()){
			commands.push(add_com(d_circle(p, i == moved_point ? 4 : 2), {"color": i == moved_point ? "red" : "black", "fill":true}));
		}	
	}
    if(document.getElementById("number_check").checked){
		for(let [i,p] of points.entries()){
			commands.push(add_com(d_text(i, lincomb(1, [4,4],1,p)), {"size":15}));
		}	
	}
	switch(mode){
		case "circles":

		break;
		case "lines":
			for(let [i,p] of points.entries()){
				if(i+1 == points.length){
					break;
				}
				commands.push(add_com(d_line(p,points[i+1]), {"color":"black", "width":2}));
			}
		break;
		case "polygon":
			commands.push({type:"drawPolygon", points_x : points.map(x => x[0]), points_y : points.map(x => x[1]), color:"#330000", fill:true})
		break;
		case "bezier":
			if(points.length == 0){
				return;
			}
			var lst2 = [...points];
			while(lst2.length % 3 != 1){
				lst2.pop();
			}
			commands = commands.concat(d_bezier(lst2, false).map(x => add_com(x, {"color":"#330000"})));
			break;
        case "bezier shape":
			if(points.length == 0){
				return;
			}
			var lst2 = [...points];
			while(lst2.length % 3 != 1){
				lst2.pop();
			}
			commands = commands.concat(d_bezier(lst2, true).map(x => add_com(x, {"color":"#330000"})));
		break;
		case "smooth bezier":
			if(points.length == 0){
				return;
			}
			var lst2 = [...points];
			while(lst2.length % 2  != 0){
				lst2.pop();
			}
			commands = commands.concat(d_smoothbezier(lst2, false).map(x => add_com(x, {"color":"#330000"})));
		break;
        case "smooth bezier shape":
			if(points.length == 0){
				return;
			}
			var lst2 = [...points];
			while(lst2.length % 2  != 0){
				lst2.pop();
			}
			commands = commands.concat(d_smoothbezier(lst2, true).map(x => add_com(x, {"color":"#330000"})));
			break;

	}
	draw_wrap(commands, c);
    document.getElementById('text').value = JSON.stringify(lst)
}
function scale(x0,x1,y0,y1) {
    noNaN([x0,x1,y0,y1]);
    // x0 -> 0, x1 -> 1 , map all along
    let lin_x = (a) => (a-x0)/(x1 - x0) ;
    let lin_y = (a) => (a-y0)/(y1 - y0) ;
    let map_pt = ([x,y]) => [lin_x(x), lin_y(y)];
    let str = JSON.stringify(lst.map(map_pt));
    document.getElementById('text').value = str;
}

function rescale(){
    let x0 = parseFloat(document.getElementById("rescale_x0").value);
    let x1 = parseFloat(document.getElementById("rescale_x1").value);
    let y0 = parseFloat(document.getElementById("rescale_y0").value);
    let y1 = parseFloat(document.getElementById("rescale_y1").value);
    scale(x0,x1,y0,y1)
}

function rescale_max(){ // max x value mapped to 1, y values mapped to 0-1, with negative = bigger
    let x0 = 0;
    let x1 = _.max(lst.map(x => x[0]));
    let y0 = _.max(lst.map(x => x[1]));
    let y1 = _.min(lst.map(x => x[1]));
    noNaN([x0,x1,y0,y1]);
    scale(x0,x1,y0,y1)

}

function rescale_01(){
    scale(0,400, 600, 0 )
}
</script>



</html>