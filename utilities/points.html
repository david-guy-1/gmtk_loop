<html>

<head>
<script type="text/javascript">
// put this into get_type.py, enter "DONE" (no quotes).
function noNaN(lst) {
    for (let f of lst) {
        if (typeof (f) == "number" && isNaN(f)) {
            throw "noNaN but is NaN";
        }
        if (Array.isArray(f)) {
            noNaN(f);
        }
    }
}
let imgStrings = {};
function make_style(ctx, style) {
    if (typeof (style) == "string") {
        return style;
    }
    if (style.type == "fill_linear") {
        let x = ctx.createLinearGradient(style.x0, style.y0, style.x1, style.y1);
    }
    else if (style.type == "fill_radial") {
        let x = ctx.createRadialGradient(style.x0, style.y0, style.r0, style.x1, style.y1, style.r1);
    }
    else if (style.type == "fill_conic") {
        let x = ctx.createConicGradient(style.theta, style.x, style.y);
    }
    else {
        throw "1";
    }
    for (let item of style.colorstops) {
        x.addColorStop(item[0], item[1]);
    }
    return x;
}
function drawImage(context, img, x, y) {
    if (imgStrings[img] == undefined) {
        return new Promise(function (r, s) {
            let im = new Image();
            im.src = img;
            im.onload = function () {
                if (context != undefined) {
                    context.drawImage(im, x, y);
                }
                imgStrings[img] = im;
                r("");
            };
        });
    }
    else {
        let im = imgStrings[img];
        context.drawImage(im, x, y);
        return new Promise((x, y) => x(""));
    }
}
function drawLine(context, x0, y0, x1, y1, color = "black", width = 1) {
    noNaN(arguments);
    //	////console.log(x0, y0, x1, y1)
    context.strokeStyle = color;
    context.lineWidth = width;
    context.beginPath();
    context.stroke();
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.stroke();
}
//draws a circle with the given coordinates (as center) and color
function drawCircle(context, x, y, r, color = "black", width = 1, fill = false, transparency = 1, start = 0, end = 2 * Math.PI) {
    noNaN(arguments);
    //////console.log(x,y,r)
    context.lineWidth = width;
    context.beginPath();
    context.arc(x, y, r, start, end);
    if (fill) {
        context.globalAlpha = transparency;
        context.fillStyle = make_style(context, color);
        context.fill();
        context.globalAlpha = 1;
    }
    else {
        context.strokeStyle = make_style(context, color);
        context.stroke();
    }
}
function drawPolygon(context, points_x, points_y, color = "black", width = 1, fill = false, transparency = 1) {
    noNaN(arguments);
    noNaN(points_x);
    noNaN(points_y);
    context.lineWidth = width;
    context.beginPath();
    context.moveTo(points_x[0], points_y[0]);
    for (let i = 1; i < points_x.length; i++) {
        context.lineTo(points_x[i], points_y[i]);
    }
    context.closePath();
    if (fill) {
        context.globalAlpha = transparency;
        context.fillStyle = make_style(context, color);
        context.fill();
        context.globalAlpha = 1;
    }
    else {
        context.strokeStyle = make_style(context, color);
        context.stroke();
    }
}
//draws a rectangle with the given coordinates and color
function drawRectangle(context, tlx, tly, brx, bry, color = "black", width = 1, fill = false, transparency = 1) {
    noNaN(arguments);
    if (fill) {
        context.globalAlpha = transparency;
        context.fillStyle = make_style(context, color);
        context.fillRect(tlx, tly, brx - tlx, bry - tly);
        context.globalAlpha = 1;
    }
    else {
        context.lineWidth = width;
        context.strokeStyle = make_style(context, color);
        context.beginPath();
        context.rect(tlx, tly, brx - tlx, bry - tly);
        context.stroke();
    }
}
// uses width and height instead of bottom right coordinates
function drawRectangle2(context, tlx, tly, width, height, color = "black", widthA = 1, fill = false, transparency = 1) {
    noNaN(arguments);
    drawRectangle(context, tlx, tly, tlx + width, tly + height, color, widthA, fill, transparency);
}
// coords are bottom left of text
function drawText(context, text_, x, y, width = undefined, color = "black", size = 20) {
    noNaN(arguments);
    context.font = size + "px Arial";
    context.fillStyle = color;
    if (width == undefined) {
        context.fillText(text_, x, y);
    }
    else {
        context.fillText(text_, x, y, width);
    }
}
// see drawRectangle
function drawEllipse(context, posx, posy, brx, bry, color = "black", transparency = 1, rotate = 0, start = 0, end = 2 * Math.PI) {
    noNaN(arguments);
    drawEllipse2(context, posx, posy, brx - posx, bry - posy, color, transparency, rotate, start, end);
}
//draw ellipse with center and radii
function drawEllipseCR(context, cx, cy, rx, ry, color = "black", transparency = 1, rotate = 0, start = 0, end = 2 * Math.PI) {
    noNaN(arguments);
    drawEllipse2(context, cx - rx, cy - ry, 2 * rx, 2 * ry, color, transparency, rotate, start, end);
}
function drawEllipse2(context, posx, posy, width, height, color = "black", transparency = 1, rotate = 0, start = 0, end = 2 * Math.PI) {
    noNaN(arguments);
    context.beginPath();
    if (color != "none") {
        context.fillStyle = make_style(context, color);
    }
    context.globalAlpha = transparency;
    context.ellipse(posx + width / 2, posy + height / 2, width / 2, height / 2, rotate, start, end);
    if (color == "none") {
        context.stroke();
    }
    else {
        context.fill();
    }
    context.globalAlpha = 1;
}
function drawBezierCurve(context, x, y, p1x, p1y, p2x, p2y, p3x, p3y, color = "black", width = 1) {
    noNaN(arguments);
    //	////console.log(x0, y0, x1, y1)
    context.strokeStyle = make_style(context, color);
    context.lineWidth = width;
    context.beginPath();
    context.moveTo(x, y);
    context.bezierCurveTo(p1x, p1y, p2x, p2y, p3x, p3y);
    context.stroke();
}
function drawBezierShape(context, x, y, curves, color = "black", width = 1) {
    noNaN(arguments);
    for (let item of curves) {
        noNaN(item);
    }
    // curves are lists of 6 points 
    context.strokeStyle = make_style(context, color);
    context.beginPath();
    context.moveTo(x, y);
    for (let curve of curves) {
        let [a, b, c, d, e, f] = curve;
        context.bezierCurveTo(a, b, c, d, e, f);
    }
    context.closePath();
    context.fillStyle = make_style(context, color);
    context.fill();
}
function drawRoundedRectangle(context, x0, y0, x1, y1, r1, r2, cap0 = false, cap1 = false, color = "black", width = 1, fill = false) {
    let perp_vector = [y1 - y0, x0 - x1];
    perp_vector = normalize(perp_vector, r1);
    let perp_vector2 = [y1 - y0, x0 - x1];
    perp_vector2 = normalize(perp_vector, r2);
    context.beginPath();
    context.moveTo(x0 + perp_vector[0], y0 + perp_vector[1]);
    context.lineTo(x1 + perp_vector2[0], y1 + perp_vector2[1]);
    let angle = Math.atan2(perp_vector[1], perp_vector[0]);
    // add pi/2 and see if it points in the same direction as p1 -> p0 
    let ccw = Math.cos(angle + Math.PI / 2) * (x0 - x1) + Math.sin(angle + Math.PI / 2) * (y0 - y1) > 0;
    if (cap0) {
        context.lineTo(x1 - perp_vector2[0], y1 - perp_vector2[1]);
    }
    else {
        context.arc(x1, y1, r2, angle, angle + Math.PI, ccw);
    }
    context.lineTo(x0 - perp_vector[0], y0 - perp_vector[1]);
    if (cap0) {
        context.arc(x0, y0, r1, Math.PI + angle, angle, ccw);
    }
    context.closePath();
    if (fill) {
        context.fillStyle = make_style(context, color);
        context.fill();
    }
    else {
        context.strokeStyle = make_style(context, color),
            context.lineWidth = width;
        context.stroke();
    }
}




</script>


</head>

<body onload="load()">
    <canvas id='bigc' width="800px" height="600px" style="border:1px solid black;zIndex:2">
        Canvas not supported
      </canvas>
      <br />
      <table><tr><td>
      <textarea id="text"></textarea><br />
      <button onclick="lst.pop();draw();">Pop (W)</button>
      <button onclick="if(prompt('confirm')){lst = []};draw();">Clear</button>
      <button onclick="document.getElementById('text').value = JSON.stringify(lst)">Save</button>
      <button onclick="lst = JSON.parse(document.getElementById('text').value);draw();">Load</button><br />
      Line<input type="checkbox" id="line" />Fill<input type="checkbox" id="fill" />
    </td><td>
        .......
    </td><td>
        x0 : <input type="text" id="rescale_x0"> x1 : <input type="text" id="rescale_x1"> <br />
        y0 : <input type="text" id="rescale_y0"> y1 : <input type="text" id="rescale_y1"> <br />
        <button onclick="rescale()">Rescale</button>
        <button onclick="rescale_max()">Rescale Max</button>
        <button onclick="rescale_01()">Rescale 01</button>
    </td>
        </tr></table>
    <br />
    <b>Rescale : </b> Given the numbers x0, x1, y0, y1 - consider the affine linear function that sends x0 to 0 and x1 to 1 (similarly for y0), maps the given points under this function <br />
    rescale max : rescales with x0 = 0, x1 = max value of x, y0 = max value of y, y1 = min value of y <br />
    rescale 01 : rescales with x0 = 0, x1 = 400, y0 = 600, y1 = 0
</body>

<script type="text/javascript" src="lodash.js"></script>
<script>
let lst = [];
let c; 
function load()  { 
    document.addEventListener("keyup", function(e){
        if(e.key.toLowerCase() == "w"){
            lst.pop(); 
            draw();
        } 
    })
    document.getElementById("bigc").addEventListener("click", function(e){ 
        lst.push([e.offsetX-400, e.offsetY]);
        draw();
    })
    c= document.getElementById("bigc").getContext("2d");
    draw();
}

function draw(){
    c.clearRect(0,0,1000,1000);
    drawLine(c, 400, 0, 400, 1000, "green", 1); 
    for(let [x,y] of lst){
        drawCircle(c, x+400, y, 2, "black");
    }
    let fill = document.getElementById("fill").checked;
    let line = document.getElementById("line").checked;
    if(fill){
        drawPolygon(c, lst.map(x => x[0]+400), lst.map(x => x[1]), "#330000", 4, true);
    } else if(line){
        drawPolygon(c, lst.map(x => x[0]+400), lst.map(x => x[1]), "#330000", 4, false);
    }
    
    document.getElementById('text').value = JSON.stringify(lst)
}
function scale(x0,x1,y0,y1) {
    noNaN([x0,x1,y0,y1]);
    // x0 -> 0, x1 -> 1 , map all along
    let lin_x = (a) => (a-x0)/(x1 - x0) ;
    let lin_y = (a) => (a-y0)/(y1 - y0) ;
    let map_pt = ([x,y]) => [lin_x(x), lin_y(y)];
    let str = JSON.stringify(lst.map(map_pt));
    document.getElementById('text').value = str;
}

function rescale(){
    let x0 = parseFloat(document.getElementById("rescale_x0").value);
    let x1 = parseFloat(document.getElementById("rescale_x1").value);
    let y0 = parseFloat(document.getElementById("rescale_y0").value);
    let y1 = parseFloat(document.getElementById("rescale_y1").value);
    scale(x0,x1,y0,y1)
}

function rescale_max(){ // max x value mapped to 1, y values mapped to 0-1, with negative = bigger
    let x0 = 0;
    let x1 = _.max(lst.map(x => x[0]));
    let y0 = _.max(lst.map(x => x[1]));
    let y1 = _.min(lst.map(x => x[1]));
    noNaN([x0,x1,y0,y1]);
    scale(x0,x1,y0,y1)

}

function rescale_01(){
    scale(0,400, 600, 0 )
}
</script>



</html>